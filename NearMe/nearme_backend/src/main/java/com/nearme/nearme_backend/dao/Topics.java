package com.nearme.nearme_backend.dao;

import com.mongodb.client.MongoDatabase;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorFindException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorListException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteException;
import com.mongodb.MongoException;
import com.mongodb.client.FindIterable;
import static com.mongodb.client.model.Filters.*;
import static com.mongodb.client.model.Sorts.descending;

import org.bson.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.time.Instant;

public class Topics extends Collection {
    private static final int MAX_ENTRIES = 100;
    Logger logger = LoggerFactory.getLogger(Topics.class);
    
    protected Topics(MongoDatabase database) {
        collection = database.getCollection("Topic");
        
        cache = new LinkedHashMap<String, Document>(MAX_ENTRIES + 1, 1.0f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<String, Document> eldest) {
                return size() > MAX_ENTRIES;
            }
        };
    }

    /**
     * Adds collection item to database if it is not already present
     *
     * @param name The name of the collection item to add
     * @return Autogenerated ID of collection item if collection item is not in database and the insert
     *         was successful, empty String otherwise
     */
    public String create(String name, String regionId, String userId) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        Document doc = new Document();
        doc.put("Name", name);
        doc.put("RegionId", regionId);
        doc.put("Timestamp", Instant.now().getEpochSecond());
        doc.put("CreatedBy", userId);
        doc.put("MessageCount", 0);
        doc.put("SubscriptionCount", 0);
        // create the topic if the name does not already exist
        return create(doc, "Name", name);
    }


    public boolean incrementMessageCount(String topicId) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        int original_count = read(topicId).getInteger("MessageCount", 0);
        return update(topicId, "MessageCount",  original_count + 1);
    }

    public boolean decrementMessageCount(String topicId) throws DatabaseAccessorFindException, DatabaseAccessorWriteException{
        int original_count = read(topicId).getInteger("MessageCount", 0);
        return update(topicId, "MessageCount",  original_count - 1);
    }

    public boolean incrementSubscriptionCount(String topicId) throws DatabaseAccessorFindException, DatabaseAccessorWriteException{
        int original_count = read(topicId).getInteger("SubscriptionCount", 0);
        return update(topicId, "SubscriptionCount",  original_count + 1);
    }

    public boolean decrementSubscriptionCount(String topicId) throws DatabaseAccessorFindException, DatabaseAccessorWriteException{
        int original_count = read(topicId).getInteger("SubscriptionCount", 0);
        return update(topicId, "SubscriptionCount",  original_count - 1);
    }

    public String getName(String id) throws DatabaseAccessorFindException {
        return read(id, "Name");
    }

    public String getID(String name) throws DatabaseAccessorFindException {
        return getID("Name", name);
    }

    public boolean deleteTopic(String topicID) throws DatabaseAccessorFindException, DatabaseAccessorListException, DatabaseAccessorWriteException {
        return ( delete(topicID) != null );
    }


    // doing get all, not gonna change lru for such action, makes no sense
    public List<String> getAllTopics() throws DatabaseAccessorFindException {
        ArrayList<String> result = new ArrayList<>();
        FindIterable<Document> doc = null;
        try {
            doc = collection.find();
        } catch (MongoException e) {
            throw new DatabaseAccessorFindException("Exception trying to find anything in topics collection", e);
        }
        if (doc != null) {
            doc.forEach(d -> {
                result.add(d.get("_id").toString());
            });
        }
        return result;
    }

    public List<String> getPopularTopics(String regionID, int count) {
        // TODO: probably need to sort by the sum of 'SubscriptionCount' and 'MessageCount' to get popularity
        FindIterable<Document> topicList = collection.find(eq("RegionId", regionID))
                                                     .sort(descending("SubscriptionCount"))
                                                     .limit(count);
        
        ArrayList<String> result = new ArrayList<>();
        if (topicList != null) {
            topicList.forEach(topic -> {
                result.add(topic.get("_id").toString());
                cache.put(topic.getObjectId("_id").toHexString(), topic);
            });
        }
        return result;
    }
}
