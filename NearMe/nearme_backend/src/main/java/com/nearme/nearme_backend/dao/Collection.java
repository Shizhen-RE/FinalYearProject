package com.nearme.nearme_backend.dao;

import com.mongodb.MongoWriteException;
import com.mongodb.MongoCommandException;
import com.mongodb.MongoException;
import com.mongodb.MongoWriteConcernException;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorFindException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteCommandException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteConcernException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteOtherException;
import com.nearme.nearme_backend.exceptions.DatabaseAccessorWriteSpecificException;

import org.bson.*;
import org.bson.types.ObjectId;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.mongodb.client.model.Filters.*;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class Collection {
    Logger logger = LoggerFactory.getLogger(Collection.class);

    protected MongoCollection<Document> collection;

    // LRU cache: retains certain number id - doc pairs that was recently requested
    // entrance/refresh condition: 
    // 1. A query on the doc was made from whatever key and to whatever key
    // Write policy: will be write-through (automatic). Please take precaution in case modifying multiple field.
    // write around for create (id is unknown until database return)
    // Used datastructure: linkedHashMap
    // No thread safety guards, reason:
    // 1. Read don't need to be
    // 2. Business logic made concurrent write impossible: people cannot modify other's
    // 3. I'm lazy
    // 4. In case iterative must happen, copy the values. (key is the id of the value)
    Map<String, Document> cache;

    /**
     * Checks to make sure given ID is valid MongoDB form
     *
     * @param name The ID to check
     * @return true if ID is a 24 character hexidecimal value in String form, false
     *         otherwise
     */
    protected boolean checkID(String id) {
        logger.trace("checkID");
        // Check if ID is the proper length
        boolean result = (id.length() == 24);
        // Check if ID is hexidecimal
        return result && id.matches("^[0-9a-fA-F]+$");
    }

    /**
     * Checks if an ID is present in a list
     *
     * @param list The list to search through
     * @param id   The ID to search for
     * @return Index of ID in list if the ID is valid and it was found in the list,
     *         -1 otherwise
     */
    protected int checkListID(List<String> list, String id) {
        logger.trace("checkListID");
        // Check if ID is valid, to avoid uneccessarily checking long lists
        if (checkID(id)) {
            // Linearly search list for ID, and return index of match in list
            for (int i = 0; i < list.size(); i++) {
                if (list.get(i).toString().equals(id)) {
                    return i;
                }
            }
        }
        // ID not found, return negative
        return -1;
    }

    /**
     * Gets ID of collection item matching key/value pair
     *
     * @param key   The key of the collection item to search for
     * @param value The value to search for in the collection
     * @return The autogenerated ID of the first collection item containing the
     *         specified key/value pair, or an empty String if no match was found
     */
    public String getID(String key, Object value) throws DatabaseAccessorFindException {
        logger.trace("getID collection base");
        try {
            // Attempt from cache
            for (Document doc: cache.values().toArray(new Document[0])) {
                if (value.equals(doc.get(key))) {
                    // cache hit
                    return doc.getObjectId("_id").toHexString();
                }
            }
            // cache miss
            Document doc = collection.find(eq(key, value)).first();
            if (doc != null) {
                return doc.get("_id").toString();
            }
        } catch (MongoException e) {
            throw new DatabaseAccessorFindException(key, value, e);
        }
        return "";
    }

    /**
     * Adds document to collection
     *
     * @param doc The document to add
     * @return Autogenerated ID of the document if the insert was successful, empty
     *         String otherwise
     */
    public String create(Document doc) throws DatabaseAccessorWriteException {
        logger.trace("create");
        if (doc != null) {
            try {
                String newDocId = collection.insertOne(doc).getInsertedId().asObjectId().getValue().toHexString();
                doc.put("_id", new ObjectId(newDocId));
                cache.put(newDocId, doc);
                return newDocId;
            } catch(MongoWriteException e) {
                throw new DatabaseAccessorWriteSpecificException("insert", e);
            } catch(MongoWriteConcernException e) {
                throw new DatabaseAccessorWriteConcernException("insert", e);
            } catch(MongoCommandException e) {
                throw new DatabaseAccessorWriteCommandException("insert", e);
            } catch(MongoException e) {
                throw new DatabaseAccessorWriteOtherException("insert", e);
            }
        }
        return "";
    }

    /**
     * Adds document to collection, if the specified key/value pair is not present
     * in the collection
     *
     * @param doc   The document to add
     * @param key   The key to search for in the collection
     * @param value The value to search for in the collection
     * @return Autogenerated ID of the document if the insert was successful and the
     *         key/value pair is not already in the collection, empty String
     *         otherwise
     */
    public String create(Document doc, String key, Object value) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        logger.trace("create with key value");
        if (getID(key, value).isEmpty()) {
            return create(doc);
        }
        return "";
    }

    /**
     * Gets value of collection item from its ID and key specifically for String field
     *
     * @param id  The ID of the collection item
     * @param key The key of the desirable value
     * @return The value of the collection item found with matching ID and key, or
     *         an empty String if no collection item was found with that ID or key,
     *         or if the ID was invalid
     */
    public String read(String id, String key) throws DatabaseAccessorFindException {
        logger.trace("read key");
        if (checkID(id)) {
            try {
                Document doc = read(id);
                if (doc != null) {
                    return doc.getString(key);
                }
            } catch (MongoException e) {
                throw new DatabaseAccessorFindException("item", id, "read", e);
            }
        }
        return "";
    }

    /**
     * Gets document from its ID
     *
     * @param id The ID of the document
     * @return The name of the collection item found, or an empty String if no
     *         collection item was found or the ID was invalid
     */
    public Document read(String id) throws DatabaseAccessorFindException {
        logger.trace("read");
        if (checkID(id)) {
            // try cache
            Document doc = cache.get(id);
            if (doc == null) {
                // cache miss
                try {
                    doc = collection.find(eq("_id", new ObjectId(id))).first();
                } catch (MongoException e) {
                    throw new DatabaseAccessorFindException("item", id, "read", e);
                }
                cache.put(id, doc);
            }
            return doc;
        }
        return null;
    }

    /**
     * Updates (replaces) document with a given ID
     * 
     * @param id  The ID of the document
     * @param doc The updated version of the document
     * @return True if the ID is valid, the document is non-null, and the document
     *         is successfully updated, false otherwise
     */
    public boolean update(String id, Document doc) throws DatabaseAccessorWriteException {
        logger.trace("update");
        if (checkID(id)) {
            // cache update
            cache.put(id, doc);
            // write through
            if (doc != null) {
                try {
                    return 1 == collection.replaceOne(eq("_id", new ObjectId(id)), doc).getModifiedCount();
                } catch(MongoWriteException e) {
                    throw new DatabaseAccessorWriteSpecificException("replace", id, e);
                } catch(MongoWriteConcernException e) {
                    throw new DatabaseAccessorWriteConcernException("replace", id, e);
                } catch(MongoCommandException e) {
                    throw new DatabaseAccessorWriteCommandException("replace", id, e);
                } catch(MongoException e) {
                    throw new DatabaseAccessorWriteOtherException("replace", id, e);
                }
            }
        }
        return false;
    }

    /**
     * Updates (replaces) a key/value pair with a given ID
     * 
     * @param id    The ID of the collection item
     * @param key   The key of the collection item value to be changed
     * @param value The value of the collection item to be changed
     * @return True if the ID is valid, the document is non-null, and the document
     *         is successfully updated, false otherwise
     */
    public boolean update(String id, String key, Object value) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        logger.trace("update key value");
        if (checkID(id)) {
            Document doc = read(id);
            doc.put(key, value);
            cache.put(id, doc);
            // write through
            if (doc != null) {
                if (doc.replace(key, value) != null) {
                    try {
                        return collection.replaceOne(eq("_id", new ObjectId(id)), doc).wasAcknowledged();
                    } catch(MongoWriteException e) {
                        throw new DatabaseAccessorWriteSpecificException("replace", id, e);
                    } catch(MongoWriteConcernException e) {
                        throw new DatabaseAccessorWriteConcernException("replace", id, e);
                    } catch(MongoCommandException e) {
                        throw new DatabaseAccessorWriteCommandException("replace", id, e);
                    } catch(MongoException e) {
                        throw new DatabaseAccessorWriteOtherException("replace", id, e);
                    }
                }
            }
        }
        return false;
    }

    /**
     * Deletes collection item (document) from database
     *
     * @param id The ID of the collection item (document) to delete
     * @return The collection item (document) deleted if the ID is valid and the
     *         deletion was successful, or null otherwise
     */
    public Document delete(String id) throws DatabaseAccessorFindException {
        // Make sure ID is valid
        if (checkID(id)) {
            // evict from cache (if there)
            cache.remove(id);
            // write through
            try {
                return collection.findOneAndDelete(eq("_id", new ObjectId(id)));
            } catch (MongoException e) {
                throw new DatabaseAccessorFindException("item", id, "delete", e);
            }
        }
        return null;
    }

    // THESE TWO FUNCTIONS ARE WEIRD HERE. I WILL SEE IF THEY MAKE SENSE HERE.
    /**
     * For a collection item that is a list of items from another collection, add an
     * item to that list
     *
     * @param primary   The ID of the collection item that contains the list
     * @param secondary The ID of the collection item that is the list element to
     *                  add
     * @param key       The key of the collection item that is the list itself
     * @return true if the secondary collection exists, the IDs are both valid, the
     *         collection items pointed to by the IDs both exist, the list exists,
     *         the element is not already in the list, and the insertion has been
     *         sucessful, false otherwise
     */
    protected boolean addToList(String docId, String toAddId, Collection ref, String key) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        logger.trace("addToList");
        // if doc don't exist.. something is thrown
        List<String> idList = getList(docId, key);
        if (ref.read(toAddId) == null || checkListID(idList, toAddId) >= 0) {
            return false;
        }
        idList.add(toAddId);
        return update(docId, key, idList);
    }

    /**
     * For a collection item that is a list of items from another collection, remove
     * an item to that list
     *
     * @param primary   The ID of the collection item that contains the list
     * @param secondary The ID of the collection item that is the list element to
     *                  remove
     * @param sec_c     The collection that the list element belongs to
     * @param key       The key of the collection item that is the list itself
     * @return true if the secondary collection exists, the IDs are both valid, the
     *         collection items pointed to by the IDs both exist, the list exists,
     *         the element is not already in the list, and the removal has been
     *         sucessful, false otherwise
     */
    protected boolean removeFromList(String docId, String toDelId, Collection ref, String key) throws DatabaseAccessorFindException, DatabaseAccessorWriteException {
        logger.trace("removeFromList");
        List<String> idList = getList(docId, key);
        if (ref.read(toDelId) == null || checkListID(idList, toDelId) < 0) {
            return false;
        }
        idList.remove(checkListID(idList, toDelId));
        return update(docId, key, idList);
    }

    /**
     * For a collection item that is a list of items, get that list
     *
     * @param id  The ID of the collection item that contains the list
     * @param key The key of the list
     * @return The list if the ID can be used to get a valid document and the
     *         document contains the list under the key, empty list otherwise
     */
    protected List<String> getList(String id, String key) throws DatabaseAccessorFindException {
        logger.trace("getList");
        Document doc = read(id);
        if (doc != null) {
            return doc.getList(key, String.class);
        }
        return new ArrayList<String>();
    }

}
